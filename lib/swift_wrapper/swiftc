#!/bin/bash

unset arch output_file_map
extract_args() {
    while [[ $# -gt 0 ]]
    do
    key="$1"

    case $key in
        -target)
        arch="$2"
        shift # past argument
        ;;
        -output-file-map)
        output_file_map="$2"
        shift #past argument
        ;;
        *)
            # unknown option
        ;;
    esac
    shift # past argument or value
    done
}

extract_args "$@"

is_debug=`basename "$0"`
exec 3>/dev/null 4>&3
if [ "$is_debug" == "swiftc_debug" ]; then
    echo "running swiftc in debug"
    set -x
    exec 3>&1 4>&2
fi

VAR_DIR=/tmp/rollout_var/swift_injections/"$arch"
mkdir -p "$VAR_DIR"

originalParams=("$@")
swift_path=`/usr/bin/xcrun -f swiftc`
error_file="$VAR_DIR"/swiftc_error
error_handler() {
    local check_last_status=$1
    local last_status=$2
    local category=$3
    echo "exec original swiftc" >&3
    unset ROLLOUT_REPLACEMENTS
    unset DYLD_FORCE_FLAT_NAMESPACE
    unset DYLD_INSERT_LIBRARIES
    "$swift_path" "${originalParams[@]}"
    local original_status=$?
    if [[ ("$check_last_status" == "false" && "$original_status" -eq "0") || ("$check_last_status" == "true" && "$original_status" -ne "$last_status") ]]; then 
       echo "ROLLOUT ERROR: $category"
       echo "going to send error to Rollout.io"
       (
           echo "$error_file"
           server="$ROLLOUT_allServicesInOneServer"
           [ -n "$ROLLOUT_allServicesInOneServer" ] || server="https://error.rollout.io"
           url="$server/build/error/$category"
           gzip -c "$error_file" | curl -sS --location --post301 --post302 -F data=@"-" "$url" 
       ) &
    else
       echo "OTHER ERROR" >&3
    fi
   
    clean 
    exit $last_status
}

clean() {
    [ -d /tmp/rollout_swiftc_generated_files_debug_location ] && {
      rm -rf /tmp/rollout_swiftc_generated_files_debug_location/*"$arch"
      mv "$VAR_DIR" /tmp/rollout_swiftc_generated_files_debug_location/"$arch"
    } || {
      rm -rf "$VAR_DIR"
    }
}

DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"
STRIPFILES=()
rollout_replacements_file="$VAR_DIR"/replacements
rollout_sources_file="$VAR_DIR"/sources
for i in "$@"
do
    [[ $i =~ RolloutGenerated\.swift$ ]] && {
        touch "$i"
        last_component=`basename "$i"`
        Rollout_Generated="$VAR_DIR"/"$last_component"
        cp "$i" "$Rollout_Generated" 2>$error_file ||  error_handler "false" $? "CopyFiles"
        echo "$i" >> "$rollout_replacements_file"
        echo "$Rollout_Generated" >> "$rollout_replacements_file"
        filename="${last_component%.*}"
        obj_file=`grep -o "${last_component}.*object.*:.*${filename}.o\"" "$output_file_map" | grep -o 'object.*' | grep -o ":.*" | grep -o "\/.*o"`
        obj_file=$(echo ${obj_file} | sed "s@\\\\@@g")
        STRIPFILES+=("$obj_file")
        continue;
    } 

    [[ $i =~ RolloutSwiftInjectionBridge\.swift$ ]] && {
        last_component=`basename "$i"`
        filename="${last_component%.*}"
        obj_file=`grep -o "${last_component}.*object.*:.*${filename}.o\"" "$output_file_map" | grep -o 'object.*' | grep -o ":.*" | grep -o "\/.*o"`
        obj_file=$(echo ${obj_file} | sed "s@\\\\@@g")
        STRIPFILES+=("$obj_file")
        continue;
    }

    [[ $i =~ \.swift$ ]] && {
        last_component=`basename "$i"`
        TEMP_FILE="$VAR_DIR"/"$last_component"
        cp "$i" "$TEMP_FILE" 2>$error_file ||  error_handler "false" $? "CopyFiles"
        echo "$TEMP_FILE" >> "$rollout_sources_file"
        echo "$i" >> "$rollout_replacements_file"
        echo "$TEMP_FILE" >> "$rollout_replacements_file"
    }
done

$DIR/../../lib/Oyster/MacOS/Oyster "$Rollout_Generated" "$rollout_sources_file" >&3 2>$error_file || error_handler "false" $? "Oyster"

export ROLLOUT_REPLACEMENTS="$rollout_replacements_file"
export DYLD_FORCE_FLAT_NAMESPACE=1
export DYLD_INSERT_LIBRARIES=$DIR/../../lib/libRolloutOverrides.dylib

"$swift_path" "$@" 2>$error_file || error_handler "true" $? "Compiler" 
cat $error_file

for i in "${STRIPFILES[@]}"
do
    strip -A "$i" 2>$error_file || error_handler "false" $? "Strip"
done

clean
